# Core.Today API Style Guide
본 문서는 API를 위한 종합 디자인 가이드입니다.
본 가이드는 현재 사용되는 문서이지만 앞으로 시간이 지나면서 새로운 스타일과 디자인 패턴이 도입 및 승인을 거쳐 추가될 예정입니다.
이러한 태도를 견지하면서 앞으로도 완전하지 않고 항상 API 디자인을 개선할 수 있는 가능성을 충분히 남겨놓을 것입니다.

## 요구사항의 수준
- 해야 합니다
- 안 됩니다
- 필요합니다
- 권장 됩니다
- 할 수 있습니다
- 선택 사항입니다

## 리소스 중심 디자인

### 디자인의 원칙
- 간단할 것
- 일관적일 것
- 사용이 간편할 것

### 디자인 흐름
본 디자인 가이드는 리소스 중심 API를 디자인할 때 다음과 같은 단계를 따르도록 권장합니다.

- API가 제공하는 리소스 유형을 결정합니다.
- 리소스 사이의 관계를 결정합니다.
- 유형 및 관계를 기준으로 리소스 이름 스키마를 결정합니다.
- 리소스 스키마를 결정합니다.
- 최소한의 메소드 집합을 리소스에 연결합니다.

### 리소스
리소스 중심 API는 일반적으로 리소스 계층 구조로 모델링됩니다.
이때 각 노드는 단순 리소스이거나 컬렉션 리소스입니다.
이러한 노드를 편의상 종종 각각 리소스와 컬렉션이라 합니다.

- 컬렉션에는 동일한 유형의 리소스 목록이 포함됩니다. 예를 들어 사용자는 연락처 컬렉션을 갖습니다.

- 리소스는 상태와 0개 이상의 하위 리소스를 갖습니다. 
  그리고 각 하위 리소스는 단순 리소스가 되거나, 혹은 컬렉션 리소스가 될 수 있습니다.

예를 들어 Gmail API는 사용자 컬렉션이 있고, 각 사용자는 메시지 컬렉션, 스레드 컬렉션, 라벨 컬렉션, 프로필 리소스, 그리고 여러 설정 리소스가 있습니다.

저장소 시스템과 REST API 사이에는 개념적으로 일치하는 부분이 있지만 리소스 중심 API를 사용하는 서비스가 반드시 데이터베이스일 필요는 없으며 리소스와 메소드를 해석하는 방식에서도 유연성이 매우 큽니다. 예를 들어 캘린더 이벤트(리소스)를 만들 때는 참석자를 위한 추가 이벤트를 만들어 이메일 초대장을 참석자들에게 보낸 다음 회의실을 예약하고 화상회의 일정을 업데이트할 수 있습니다.

### 메소드
리소스 중심 API의 주요 특징은 리소스에서 실행되는 메소드(기능)보다 리소스(데이터 모델)를 강조한다는 점입니다.
일반적인 리소스 중심 API는 다수의 리소스와 소수의 메소드를 함께 제공합니다.
이때 메소드는 표준 메소드 또는 커스텀 메소드가 될 수 있습니다.
이 가이드의 표준 메서드는 `List`, `Get`, `Create`, `Update`, `Delete` 입니다.

API 기능이 표준 메소드의 하나에 자연적으로 매핑되는 경우에는 해당 메소드를 API 디자인에 사용해야 합니다.
기능이 표준 메서드 중 하나에 자연적으로 매핑되지 않을 경우에는 커스텀 메서드를 사용할 수 있습니다.
커스텀 메서드는 데이터베이스 트랜잭션 또는 데이터 분석과 같은 공통 프로그래밍 패턴을 구현하는 데 사용될 수 있습니다.

### 예시
#### Gmail API
- API 서비스: gmail.googleapis.com
  - 사용자 컬렉션: users/* 각 사용자는 다음과 같은 리소스를 갖습니다.
    - 메시지 컬렉션: `users/*/messages/*`
    - 스레드 컬렉션: `users/*/threads/*`
    - 라벨 컬렉션: `users/*/labels/*`
    - 변경 내역 컬렉션: `users/*/history/*`
    - 사용자 프로필을 나타내는 리소스: `users/*/profile`
    - 사용자 설정을 나타내는 리소스: `users/*/settings`

#### Cloud Pub/Sub API
pubsub.googleapis.com 서비스는 다음 리소스 모델을 정의하는 Cloud Pub/Sub API를 구현합니다.
- API 서비스: pubsub.googleapis.com
  - 주제 컬렉션: projects/*/topics/*
  - 구독 컬렉션: projects/*/subscriptions/*

#### Cloud Spanner API
spanner.googleapis.com 서비스는 다음 리소스 모델을 정의하는 Cloud Spanner API를 구현합니다.

- API 서비스: spanner.googleapis.com
  - 인스턴스 컬렉션: projects/*/instances/*
    - 인스턴스 작업 컬렉션: projects/*/instances/*/operations/*
    - 데이터베이스 컬렉션: projects/*/instances/*/databases/*
    - 데이터베이스 작업 컬렉션: projects/*/instances/*/databases/*/operations/*
    - 데이터베이스 세션 컬렉션: projects/*/instances/*/databases/*/sessions/*

-----

## 리소스 이름
리소스 중심 API에서 리소스는 이름이 지정된 개체이고, 리소스 이름은 식별자입니다.
리소스마다 고유한 리소스 이름이 있어야 합니다.
리소스 이름은 리소스 자체의 ID와 상위 리소스의 ID, 그리고 API 서비스 이름으로 구성됩니다.

-----

## 표준 메서드
`List`, `Get`, `Create`, `Update`, `Delete` 개념을 정의합니다.
표준 메소드는 복잡성을 줄일 뿐만 아니라 일관성을 높이는 효과가 있습니다.

| 표준 메소드 |          HTTP 매핑          | HTTP 요청 본문 |      HTTP 응답 본문     |
|:-----------:|:---------------------------:|:--------------:|:-----------------------:|
| List        | GET <collection URL>        | 해당 없음      | 리소스* 목록            |
| Get         | GET <resource URL>          | 해당 없음      | 리소스*                 |
| Create      | POST <collection URL>       | 리소스         | 리소스*                 |
| Update      | PUT or PATCH <resource URL> | 리소스         | 리소스*                 |
| Delete      | DELETE <resource URL>       | 해당 없음      | Empty** |

*메서드가 반환될 필드 하위 집합을 지정하는 응답 필드 마스크를 지원할 경우 List, Get, Create, Update 메서드에서 반환되는 리소스에 일부 데이터가 포함될 수 있습니다.
경우에 따라 API 플랫폼이 모든 메소드에 대해 필드 마스크를 기본적으로 지원하기도 합니다.

**리소스를 즉시 삭제하지 않는 Delete 메서드에서 반환되는 응답(예: 플래그 업데이트 또는 장기 실행 삭제 작업 만들기)에는 장기 실행 작업 또는 수정된 리소스가 포함되어야 합니다.

또한 단일 API를 호출하는 시간 범위 내에 요청이 완료되지 않으면 표준 메서드가 장기 실행 작업을 반환할 수도 있습니다.

### List
List 메서드는 컬렉션 이름과 매개변수 0개 이상을 입력으로 사용하고 입력과 일치하는 리소스 목록을 반환합니다.

List는 일반적으로 리소스를 검색하는 데 사용됩니다.
List는 단일 컬렉션에서 크기가 제한적이고 캐시되지 않는 데이터에 적합합니다.
더욱 광범위한 경우에는 커스텀 메소드 Search를 사용해야 합니다.

일괄 가져오기(예: 여러 리소스 ID를 입력한 후 각 ID에 해당하는 객체를 반환하는 메서드)는 List가 아닌 커스텀 BatchGet 메서드로 구현되어야 합니다.
하지만 동일한 기능을 제공하는 기존 List 메서드가 이미 있으면 대신 이를 위해 List 메서드를 재사용할 수 있습니다.
커스텀 BatchGet 메서드를 사용할 경우 이 메서드는 HTTP GET에 매핑되어야 합니다.

#### HTTP 매핑 :
- List 메서드는 HTTP `GET` 동사를 사용해야 합니다.
- 리소스가 나열되는 컬렉션 이름을 수신하는 요청 메시지 필드는 URL 경로로 매핑되어야 합니다.
  컬렉션 이름이 URL 경로에 매핑되면 URL 템플릿의 마지막 세그먼트(컬렉션 ID)는 리터럴이어야 합니다.
- 그 밖에 모든 요청 메시지 필드는 URL 쿼리 매개변수로 매핑되어야 합니다.
- 요청 본문이 없으므로 API 구성에서 body 절을 선언해서는 안 됩니다.
- 응답 본문에는 선택 사항인 메타데이터와 함께 리소스 목록이 포함되어야 합니다.

### Get
Get 메서드는 리소스 이름과 매개변수 0개 이상을 사용하고 지정된 리소스를 반환합니다.

#### HTTP 매핑 :
- Get 메서드는 HTTP `GET` 동사를 사용해야 합니다.
- 리소스 이름을 수신하는 요청 메시지 필드는 URL 경로로 매핑되어야 합니다.
- 그 밖에 모든 요청 메시지 필드는 URL 쿼리 매개변수로 매핑되어야 합니다.
- 요청 본문이 없으므로 API 구성에서 body 절을 선언해서는 안 됩니다.
- 반환되는 리소스는 전체 응답 본문으로 매핑되어야 합니다.

### Create
Create 메서드는 상위 리소스 이름, 리소스, 매개변수 0개 이상을 사용합니다.
지정된 상위 리소스 아래 새로운 리소스를 만들고 새롭게 만들어진 리소스를 반환합니다.

API에서 리소스 생성을 지원할 경우 만들 수 있는 리소스 유형마다 Create 메서드가 있어야 합니다.

#### HTTP 매핑 :
- Create 메서드는 HTTP POST 동사를 사용해야 합니다.
- 요청 메시지에는 리소스를 만들 상위 리소스 이름을 지정하는 parent 필드가 있어야 합니다.
- 리소스가 포함되는 요청 메시지 필드는 HTTP 요청 본문으로 매핑되어야 합니다. google.api.http 주석이 Create 메서드에 사용될 경우 body: "<resource_field>" 형식을 사용해야 합니다.
- 요청에는 호출자가 클라이언트에서 할당되는 id를 선택하도록 <resource>_id라고 하는 필드가 포함될 수 있습니다. 이 필드는 리소스 안에 있을 수 있습니다.
- 그 밖에 모든 요청 메시지 필드는 URL 쿼리 매개변수로 매핑되어야 합니다.
- 반환되는 리소스는 전체 HTTP 응답 본문으로 매핑되어야 합니다.

Create 메서드가 클라이언트에서 할당된 리소스 이름을 지원하고 이 리소스가 이미 있으면 요청이 오류 코드 ALREADY_EXISTS와 함께 실패하거나 다른 서버에서 할당된 리소스 이름을 사용해야 하고 생성된 리소스 이름이 전달된 리소스 이름과 다를 수 있다는 점을 명시해야 합니다.

리소스 스키마가 변경될 때 요청 스키마와 리소스 스키마 모두 업데이트할 필요가 없도록 Create 메서드는 입력 리소스를 취해야 합니다.
클라이언트에서 설정할 수 없는 리소스 필드의 경우에는 '출력 전용' 필드로 명시되어야 합니다.


### Update
Update 메서드는 리소스와 매개변수 0개 이상이 포함된 요청 메시지를 사용합니다.
이 메소드가 실행되면 지정한 리소스와 속성을 업데이트하고 업데이트된 리소스를 반환합니다.

리소스의 이름 또는 상위 리소스가 포함된 속성을 제외하고 변경 가능한 리소스 속성은 Update 메서드를 통해 변경 가능해야 합니다.
리소스 이름 변경 또는 이동에 대한 기능은 Update 메서드에서 구현되어서는 안 되고 대신 커스텀 메서드에서 처리되어야 합니다.

#### HTTP 매핑 :
- 표준 Update 메서드는 리소스 부분 업데이트를 지원해야 하고 update_mask라고 하는 FieldMask 필드와 함께 HTTP 동사 PATCH를 사용합니다. 클라이언트에서 입력으로 제공하는 출력 필드를 무시해야 합니다.
- 반복되는 필드에 첨부하는 등 고급 패치 시맨틱스가 필요한 Update 메서드는 커스텀 메서드로 구현되어야 합니다.
- Update 메서드가 전체 리소스 업데이트만 지원할 경우 HTTP 동사 PUT을 사용해야 합니다. 하지만 전체 업데이트는 새로운 리소스 필드를 추가할 때 하위 호환성 문제가 발생하므로 사용하지 않는 것이 좋습니다.
- 리소스 이름을 수신하는 메시지 필드는 URL 경로로 매핑되어야 합니다. 이 필드는 리소스 메시지 자체에 포함될 수도 있습니다.
- 리소스가 포함되는 요청 메시지 필드는 요청 본문으로 매핑되어야 합니다.
- 그 밖에 모든 요청 메시지 필드는 URL 쿼리 매개변수로 매핑되어야 합니다.
- 응답 메시지는 업데이트된 리소스 자체가 되어야 합니다.

API가 클라이언트에서 할당된 리소스 이름을 허용하는 경우 서버는 클라이언트가 존재하지 않는 리소스 이름을 지정하여 새로운 리소스를 만들도록 허용할 수 있습니다.
그렇지 않으면 Update 메서드가 존재하지 않는 리소스 이름으로 인해 실패해야 합니다.
이것이 유일한 오류 조건이라면 오류 코드 NOT_FOUND를 사용해야 합니다.

리소스를 만들 수 있는 Update 메서드가 포함된 API는 Create 메서드도 제공해야 합니다.
Update 메서드가 이를 위한 유일한 방법인 경우 리소스를 만드는 방법이 명확하지 않기 때문입니다.


### Delete
Delete 메서드는 리소스 이름과 매개변수 0개 이상을 사용하고 지정된 리소스를 삭제하거나 삭제 예약합니다.
Delete 메서드는 Empty를 반환해야 합니다.

API는 Delete 메서드에서 반환된 정보를 반복적으로 호출할 수 없으므로 사용해서는 안 됩니다.

#### HTTP 매핑 :
- Delete 메서드는 HTTP DELETE 동사를 사용해야 합니다.
- 리소스 이름을 수신하는 요청 메시지 필드는 URL 경로로 매핑되어야 합니다.
- 그 밖에 모든 요청 메시지 필드는 URL 쿼리 매개변수에 매핑되어야 합니다.
- 요청 본문이 없으므로 API 구성에서 body 절을 선언해서는 안 됩니다.
- Delete 메서드가 리소스를 즉시 삭제할 경우 빈 응답을 반환해야 합니다.
- Delete 메서드가 장기 실행 작업을 시작하면 장기 실행 작업을 반환해야 합니다.
- Delete 메서드가 리소스를 삭제 중으로만 표시할 경우 업데이트된 리소스를 반환해야 합니다.

Delete 메서드 호출은 실제로 멱등성이어야 하지만 동일한 응답을 생성할 필요는 없습니다.
Delete 요청 개수와 상관없이 리소스는 최종적으로 삭제되어야 하지만 첫 번째 요청에서만 성공 코드를 반환해야 합니다.
이후 요청은 NOT_FOUND가 되어야 합니다.

## websocket
웹소켓은 별도의 지침을 구성합니다.  
웹브라우저 정책에 따라 wss만 지원합니다.  

## 참고자료
뼈대는 다음의 가이드라인을 따릅니다
- [Google Cloud API](https://cloud.google.com/apis/design)
- [Azure REST API Guidelines](https://github.com/microsoft/api-guidelines)
